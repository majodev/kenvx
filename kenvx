#!/bin/bash
set -Eeo pipefail

# Function to display usage
usage() {
    ORIGIN_SCRIPT=$(basename "$0")

    echo "Usage: $ORIGIN_SCRIPT <kubernetes_object> [kubectl_args...] [-- command [args...]]"
    echo "Examples:"
    echo "  $ORIGIN_SCRIPT deployment/myapp                                   # Print all environment variables of deployment myapp"
    echo "  $ORIGIN_SCRIPT deployment/myapp -c container                      # Print environment variables from container of deployment myapp"
    echo "  $ORIGIN_SCRIPT cronjob/backup MY_VAR=override                     # Print environment variables with override"
    echo "  $ORIGIN_SCRIPT deployment/myapp -- env                            # Run local command with all environment variables of deployment myapp"
    echo "  $ORIGIN_SCRIPT deployment/myapp -c container -- env               # Run local command with environment from container"
    echo "  $ORIGIN_SCRIPT cronjob/backup MY_VAR=override -- env              # Run local command with environment override"
    exit 1
}

# Initialize variables
RESOURCE=""
NAMESPACE=""
CONTAINER=""
ENV_VARS=()
COMMAND_AND_ARGS=()

# Parse arguments
while [[ $# -gt 0 ]]; do
    if [ "$1" = "--" ]; then
        shift
        COMMAND_AND_ARGS=("$@")
        break
    fi

    case $1 in
        */*)
            RESOURCE="$1"
            shift
            ;;
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        --namespace=*)
            NAMESPACE="${1#*=}"
            shift
            ;;
        -c|--container)
            CONTAINER="$2"
            shift 2
            ;;
        --container=*)
            CONTAINER="${1#*=}"
            shift
            ;;
        *=*)
            ENV_VARS+=("$1")
            shift
            ;;
        *)
            echo "Error: Invalid argument '$1'"
            usage
            ;;
    esac
done

# Validate mandatory resource argument
if [[ -z "$RESOURCE" ]]; then
    echo "Error: Resource (kind/name) is required"
    usage
fi

# Build kubectl arguments array for get commands
KUBECTL_GET_ARGS=()
[[ -n "$NAMESPACE" ]] && KUBECTL_GET_ARGS+=("-n" "$NAMESPACE")

# Check if the resource exists
kubectl get "$RESOURCE" "${KUBECTL_GET_ARGS[@]}" >/dev/null

# Build kubectl arguments array for env list command
KUBECTL_ENV_ARGS=("$RESOURCE")
[[ -n "$NAMESPACE" ]] && KUBECTL_ENV_ARGS+=("-n" "$NAMESPACE")
[[ -n "$CONTAINER" ]] && KUBECTL_ENV_ARGS+=("-c" "$CONTAINER")

# Add environment variable overrides
for env in "${ENV_VARS[@]}"; do
    KUBECTL_ENV_ARGS+=("--env=$env")
done

# Temporary file to store environment variables
TMP_ENV_FILE=$(mktemp)
trap 'rm -f "$TMP_ENV_FILE"' EXIT

# Extract environment variables using kubectl set env
kubectl set env "${KUBECTL_ENV_ARGS[@]}" --resolve --list --overwrite=true --dry-run='client' 2>/dev/null \
    | (grep -v '^#' || true) \
    > "$TMP_ENV_FILE"

# Get all containers (regular and init) with their envFrom references
if CONTAINERS_JSON=$(kubectl get "$RESOURCE" "${KUBECTL_GET_ARGS[@]}" -o json | \
    jq -r '
    # First, determine the path to containers based on resource type
    (if .spec.jobTemplate then
        .spec.jobTemplate.spec.template.spec
    elif .spec.template then
        .spec.template.spec
    else
        .spec
    end) as $spec |
    # Combine both regular and init containers if they exist
    {
        containers: ($spec.containers // []),
        initContainers: ($spec.initContainers // [])
    }') && [ "$CONTAINERS_JSON" != "" ]; then


    # Process both container types
    echo "$CONTAINERS_JSON" | \
    jq -r '
    # Process both container arrays
    (.containers + .initContainers)[] |
    select(.envFrom) |
    .envFrom[] |
    select(.configMapRef != null or .secretRef != null) |
    if .configMapRef then
        {"type":"configmap","name":.configMapRef.name}
    else
        {"type":"secret","name":.secretRef.name}
    end |
    [.type,.name] |
    @tsv' | \
    while IFS=$'\t' read -r ref_type ref_name; do
        [ "$ref_type" = "" ] && continue
        
        case "$ref_type" in
            "configmap")
                kubectl get configmap "$ref_name" "${KUBECTL_GET_ARGS[@]}" -o json 2>/dev/null | \
                    jq -r '.data // {} | to_entries | map("\(.key)=\(.value)") | .[]' || true
                ;;
            "secret")
                kubectl get secret "$ref_name" "${KUBECTL_GET_ARGS[@]}" -o json 2>/dev/null | \
                    jq -r '.data // {} | to_entries | map("\(.key)=\(.value | @base64d)") | .[]' || true
                ;;
        esac
    done >> "$TMP_ENV_FILE"
fi

# If no command is provided, just print the environment variables
if [ ${#COMMAND_AND_ARGS[@]} -eq 0 ]; then
    cat "$TMP_ENV_FILE"
    exit 0
fi

# Otherwise execute the command with the extracted environment variables
TEMP_SCRIPT=$(mktemp)
trap 'rm -f "$TEMP_SCRIPT" "$TMP_ENV_FILE"' EXIT

# Process env vars handling multiline values
{
    current_key=""
    current_value=""
    
    while IFS= read -r line; do
        if [[ $line =~ ^([^=]+)=(.*) ]]; then
            if [ "$current_key" != "" ]; then
                # Escape single quotes and backslashes
                escaped_value=$(printf '%s' "$current_value" | sed "s/'/'\\\\''/g")
                printf "export %s=$'%s'\n" "$current_key" "$escaped_value"
            fi
            current_key="${BASH_REMATCH[1]}"
            current_value="${BASH_REMATCH[2]}"
        else
            current_value+=$'\n'"$line"
        fi
    done < "$TMP_ENV_FILE"
    
    # Handle last entry
    if [ "$current_key" != "" ]; then
        escaped_value=$(printf '%s' "$current_value" | sed "s/'/'\\\\''/g")
        printf "export %s=$'%s'\n" "$current_key" "$escaped_value"
    fi
} > "$TEMP_SCRIPT"

# cat $TEMP_SCRIPT >&3

# Source exports and run command
# shellcheck source=/dev/null
source "$TEMP_SCRIPT"
exec "${COMMAND_AND_ARGS[@]}"